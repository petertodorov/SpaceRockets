{"version":3,"sources":["webpack:///webpack/bootstrap 4aaab67b9c563a1461ac","webpack:///./index.js"],"names":["Smoothie","options","engine","PIXI","renderer","undefined","root","update","interpolate","fps","renderFps","properties","position","rotation","size","scale","alpha","tile","Error","particles","ParticleContainer","Sprite","renderingEngine","Container","AnimatedSprite","extras","stage","_fps","_renderFps","paused","_startTime","Date","now","_frameDuration","_lag","_lagOffset","_renderStartTime","_renderDuration","gameLoop","timestamp","requestAnimationFrame","bind","current","elapsed","capturePreviousSpriteProperties","render","setProperties","sprite","_previousX","x","_previousY","y","_previousRotation","_previousWidth","width","_previousHeight","height","_previousScaleX","_previousScaleY","_previousAlpha","tilePosition","_previousTilePositionX","_previousTilePositionY","tileScale","_previousTileScaleX","_previousTileScaleY","children","length","i","child","lagOffset","interpolateSprite","_currentX","_currentY","_currentRotation","_currentWidth","_currentHeight","_currentScaleX","_currentScaleY","_currentAlpha","_currentTilePositionX","_currentTilePositionY","_currentTileScaleX","_currentTileScaleY","j","restoreSpriteProperties","value"],"mappings":"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","file":"smoothie.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4aaab67b9c563a1461ac","export default class Smoothie {\n  constructor (\n    options = {\n      // The rendering engine (Pixi)\n      engine: PIXI,\n      // The Pixi renderer you created in your application\n      renderer: undefined,\n      // The root Pixi display object (usually the `stage`)\n      root: undefined,\n      // A logic function that should be called every frame of the game loop\n      update: undefined,\n      // A Boolean to turn interpolation on or off\n      interpolate: true,\n      // The frame rate at which the application's looping logic function should update\n      fps: 60,\n      // The frame rate at which sprites should be rendered\n      renderFps: undefined,\n      // Sprite roperties that should be interpolated\n      properties: {\n        position: true,\n        rotation: true,\n        size: false,\n        scale: false,\n        alpha: false,\n        // Refers to `tileposition` and `tileScale` x and y properties\n        tile: false\n      }\n    }\n  ) {\n    if (options.engine === undefined) throw new Error(\"Please assign a rendering engine as Smoothie's engine option\")\n\n    // Find out which rendering engine is being used (the default is Pixi)\n    this.engine = ''\n\n    // If the `renderingEngine` is Pixi, set up Pixi object aliases\n    if (options.engine.particles.ParticleContainer && options.engine.Sprite) {\n      this.renderingEngine = 'pixi'\n      this.Container = options.engine.Container\n      this.Sprite = options.engine.Sprite\n      this.AnimatedSprite = options.engine.extras.AnimatedSprite\n    }\n\n    // Check to make sure the user had supplied a renderer. If you're\n    // using Pixi, this should be the instantiated `renderer` object\n    // that you created in your main application\n    if (options.renderer === undefined) {\n      throw new Error(\"Please assign a renderer object as Smoothie's renderer option\")\n    } else {\n      this.renderer = options.renderer\n    }\n\n    // Check to make sure the user has supplied a root container. This\n    // is the object is at the top of the display list heirarchy. If\n    // you're using Pixi, it would be a `Container` object, often by\n    // convention called the `stage`\n    if (options.root === undefined) {\n      throw new Error(\"Please assign a root container object (the stage) as Smoothie's root option\")\n    } else {\n      this.stage = options.root\n    }\n\n    if (options.update === undefined) {\n      throw new Error(\"Please assign a function that you want to update on each frame as Smoothie's update option\")\n    } else {\n      this.update = options.update\n    }\n\n    // Define the sprite properties that should be interpolated\n    if (options.properties === undefined) {\n      this.properties = { position: true, rotation: true }\n    } else {\n      this.properties = options.properties\n    }\n\n    // The upper-limit frames per second that the game' logic update\n    // function should run at.\n    // Smoothie defaults to 60 fps.\n    if (options.fps !== undefined) {\n      this._fps = options.fps\n    } else {\n      this._fps = undefined\n    }\n\n    // Optionally Clamp the upper-limit frame rate at which sprites should render\n    if (options.renderFps !== undefined) {\n      this._renderFps = options.renderFps\n    } else {\n      this._renderFps = undefined\n    }\n    // Set sprite rendering position interpolation to\n    // `true` by default\n    if (options.interpolate === false) {\n      this.interpolate = false\n    } else {\n      this.interpolate = true\n    }\n\n    // A variable that can be used to pause and play Smoothie\n    this.paused = false\n\n    // Private properties used to set the frame rate and figure out the interpolation values\n    this._startTime = Date.now()\n    this._frameDuration = 1000 / this._fps\n    this._lag = 0\n    this._lagOffset = 0\n\n    this._renderStartTime = 0\n    if (this._renderFps !== undefined) {\n      this._renderDuration = 1000 / this._renderFps\n    }\n  }\n\n  // Getters and setters\n\n  // Fps\n  get fps () { return this._fps }\n  set fps (value) {\n    this._fps = value\n    this._frameDuration = 1000 / this._fps\n  }\n\n  // renderFps\n  get renderFps () { return this._renderFps }\n  set renderFps (value) {\n    this._renderFps = value\n    this._renderDuration = 1000 / this._renderFps\n  }\n\n  // `dt` (Delta time, the `this._lagOffset` value in Smoothie's code)\n  get dt () { return this._lagOffset }\n\n  // Methods to pause and resume Smoothie\n  pause () {\n    this.paused = true\n  }\n  resume () {\n    this.paused = false\n  }\n\n  // The `start` method gets Smoothie's game loop running\n  start () {\n    // Start the game loop\n    this.gameLoop()\n  }\n\n  // The core game loop\n  gameLoop (timestamp) {\n    requestAnimationFrame(this.gameLoop.bind(this))\n\n    // Only run if Smoothie isn't paused\n    if (!this.paused) {\n      // The `interpolate` function updates the logic function at the\n      // same rate as the user-defined fps, renders the sprites, with\n      // interpolation, at the maximum frame rate the system is capbale\n      // of\n\n      const interpolate = () => {\n        // Calculate the time that has elapsed since the last frame\n        let current = Date.now()\n        let elapsed = current - this._startTime\n\n        // Catch any unexpectedly large frame rate spikes\n        if (elapsed > 1000) elapsed = this._frameDuration\n\n        // For interpolation:\n        this._startTime = current\n\n        // Add the elapsed time to the lag counter\n        this._lag += elapsed\n\n        // Update the frame if the lag counter is greater than or\n        // equal to the frame duration\n        while (this._lag >= this._frameDuration) {\n          // Capture the sprites' previous properties for rendering\n          // interpolation\n          this.capturePreviousSpriteProperties()\n\n          // Update the logic in the user-defined update function\n          this.update()\n\n          // Reduce the lag counter by the frame duration\n          this._lag -= this._frameDuration\n        }\n\n        // Calculate the lag offset and use it to render the sprites\n        this._lagOffset = this._lag / this._frameDuration\n        this.render(this._lagOffset)\n      }\n\n      // If the `fps` hasn't been defined, call the user-defined update\n      // function and render the sprites at the maximum rate the\n      // system is capable of\n      if (this._fps === undefined) {\n        // Run the user-defined game logic function each frame of the\n        // game at the maxium frame rate your system is capable of\n        this.update()\n        this.render()\n      } else if (this._renderFps === undefined) {\n        interpolate()\n      } else {\n        // Implement optional frame rate rendering clamping\n        if (timestamp >= this._renderStartTime) {\n          // Update the current logic frame and render with\n          // interpolation\n          interpolate()\n\n          // Reset the frame render start time\n          this._renderStartTime = timestamp + this._renderDuration\n        }\n      }\n    }\n  }\n\n  // `capturePreviousSpritePositions`\n  // This function is run in the game loop just before the logic update\n  // to store all the sprites' previous positions from the last frame.\n  // It allows the render function to interpolate the sprite positions\n  // for ultra-smooth sprite rendering at any frame rate\n  capturePreviousSpriteProperties () {\n    // A function that capture's the sprites properties\n    const setProperties = (sprite) => {\n      if (this.properties.position) {\n        sprite._previousX = sprite.x\n        sprite._previousY = sprite.y\n      }\n      if (this.properties.rotation) {\n        sprite._previousRotation = sprite.rotation\n      }\n      if (this.properties.size) {\n        sprite._previousWidth = sprite.width\n        sprite._previousHeight = sprite.height\n      }\n      if (this.properties.scale) {\n        sprite._previousScaleX = sprite.scale.x\n        sprite._previousScaleY = sprite.scale.y\n      }\n      if (this.properties.alpha) {\n        sprite._previousAlpha = sprite.alpha\n      }\n      if (this.properties.tile) {\n        if (sprite.tilePosition !== undefined) {\n          sprite._previousTilePositionX = sprite.tilePosition.x\n          sprite._previousTilePositionY = sprite.tilePosition.y\n        }\n        if (sprite.tileScale !== undefined) {\n          sprite._previousTileScaleX = sprite.tileScale.x\n          sprite._previousTileScaleY = sprite.tileScale.y\n        }\n      }\n\n      if (sprite.children && sprite.children.length > 0) {\n        for (let i = 0; i < sprite.children.length; i++) {\n          const child = sprite.children[i]\n          setProperties(child)\n        }\n      }\n    }\n\n    // loop through the all the sprites and capture their properties\n    for (let i = 0; i < this.stage.children.length; i++) {\n      const sprite = this.stage.children[i]\n      setProperties(sprite)\n    }\n  }\n\n  // Smoothie's `render` method will interpolate the sprite positions and\n  // rotation for\n  // ultra-smooth animation, if Hexi's `interpolate` property is `true`\n  // (it is by default)\n  render (lagOffset = 1) {\n    // Calculate the sprites' interpolated render positions if\n    // `this.interpolate` is `true` (It is true by default)\n\n    if (this.interpolate) {\n      // A recursive function that does the work of figuring out the\n      // interpolated positions\n      const interpolateSprite = (sprite) => {\n        // Position (`x` and `y` properties)\n        if (this.properties.position) {\n          // Capture the sprite's current x and y positions\n          sprite._currentX = sprite.x\n          sprite._currentY = sprite.y\n\n          // Figure out its interpolated positions\n          if (sprite._previousX !== undefined) {\n            sprite.x = (sprite.x - sprite._previousX) * lagOffset + sprite._previousX\n          }\n          if (sprite._previousY !== undefined) {\n            sprite.y = (sprite.y - sprite._previousY) * lagOffset + sprite._previousY\n          }\n        }\n\n        // Rotation (`rotation` property)\n        if (this.properties.rotation) {\n          // Capture the sprite's current rotation\n          sprite._currentRotation = sprite.rotation\n\n          // Figure out its interpolated rotation\n          if (sprite._previousRotation !== undefined) {\n            sprite.rotation = (sprite.rotation - sprite._previousRotation) * lagOffset + sprite._previousRotation\n          }\n        }\n\n        // Size (`width` and `height` properties)\n        if (this.properties.size) {\n          // Only allow this for Sprites or AnimatedSprites. Because\n          // Containers vary in size when the sprites they contain\n          // move, the interpolation will cause them to scale erraticly\n          if (sprite instanceof this.Sprite || sprite instanceof this.AnimatedSprite) {\n            // Capture the sprite's current size\n            sprite._currentWidth = sprite.width\n            sprite._currentHeight = sprite.height\n\n            // Figure out the sprite's interpolated size\n            if (sprite._previousWidth !== undefined) {\n              sprite.width = (sprite.width - sprite._previousWidth) * lagOffset + sprite._previousWidth\n            }\n            if (sprite._previousHeight !== undefined) {\n              sprite.height = (sprite.height - sprite._previousHeight) * lagOffset + sprite._previousHeight\n            }\n          }\n        }\n\n        // Scale (`scale.x` and `scale.y` properties)\n        if (this.properties.scale) {\n          // Capture the sprite's current scale\n          sprite._currentScaleX = sprite.scale.x\n          sprite._currentScaleY = sprite.scale.y\n\n          // Figure out the sprite's interpolated scale\n          if (sprite._previousScaleX !== undefined) {\n            sprite.scale.x = (sprite.scale.x - sprite._previousScaleX) * lagOffset + sprite._previousScaleX\n          }\n          if (sprite._previousScaleY !== undefined) {\n            sprite.scale.y = (sprite.scale.y - sprite._previousScaleY) * lagOffset + sprite._previousScaleY\n          }\n        }\n\n        // Alpha (`alpha` property)\n        if (this.properties.alpha) {\n          // Capture the sprite's current alpha\n          sprite._currentAlpha = sprite.alpha\n\n          // Figure out its interpolated alpha\n          if (sprite._previousAlpha !== undefined) {\n            sprite.alpha = (sprite.alpha - sprite._previousAlpha) * lagOffset + sprite._previousAlpha\n          }\n        }\n\n        // Tiling sprite properties (`tileposition` and `tileScale` x\n        // and y values)\n        if (this.properties.tile) {\n          // `tilePosition.x` and `tilePosition.y`\n          if (sprite.tilePosition !== undefined) {\n            // Capture the sprite's current tile x and y positions\n            sprite._currentTilePositionX = sprite.tilePosition.x\n            sprite._currentTilePositionY = sprite.tilePosition.y\n\n            // Figure out its interpolated positions\n            if (sprite._previousTilePositionX !== undefined) {\n              sprite.tilePosition.x = (sprite.tilePosition.x - sprite._previousTilePositionX) * lagOffset + sprite._previousTilePositionX\n            }\n            if (sprite._previousTilePositionY !== undefined) {\n              sprite.tilePosition.y = (sprite.tilePosition.y - sprite._previousTilePositionY) * lagOffset + sprite._previousTilePositionY\n            }\n          }\n\n          // `tileScale.x` and `tileScale.y`\n          if (sprite.tileScale !== undefined) {\n            // Capture the sprite's current tile scale\n            sprite._currentTileScaleX = sprite.tileScale.x\n            sprite._currentTileScaleY = sprite.tileScale.y\n\n            // Figure out the sprite's interpolated scale\n            if (sprite._previousTileScaleX !== undefined) {\n              sprite.tileScale.x = (sprite.tileScale.x - sprite._previousTileScaleX) * lagOffset + sprite._previousTileScaleX\n            }\n            if (sprite._previousTileScaleY !== undefined) {\n              sprite.tileScale.y = (sprite.tileScale.y - sprite._previousTileScaleY) * lagOffset + sprite._previousTileScaleY\n            }\n          }\n        }\n\n        // Interpolate the sprite's children, if it has any\n        if (sprite.children.length !== 0) {\n          for (let j = 0; j < sprite.children.length; j++) {\n            // Find the sprite's child\n            const child = sprite.children[j]\n\n            // display the child\n            interpolateSprite(child)\n          }\n        }\n      }\n\n      // loop through the all the sprites and interpolate them\n      for (let i = 0; i < this.stage.children.length; i++) {\n        const sprite = this.stage.children[i]\n        interpolateSprite(sprite)\n      }\n    }\n\n    // Render the stage. If the sprite positions have been\n    // interpolated, those position values will be used to render the\n    // sprite\n    this.renderer.render(this.stage)\n\n    // Restore the sprites' original x and y values if they've been\n    // interpolated for this frame\n    if (this.interpolate) {\n      // A recursive function that restores the sprite's original,\n      // uninterpolated x and y positions\n      const restoreSpriteProperties = (sprite) => {\n        if (this.properties.position) {\n          sprite.x = sprite._currentX\n          sprite.y = sprite._currentY\n        }\n        if (this.properties.rotation) {\n          sprite.rotation = sprite._currentRotation\n        }\n        if (this.properties.size) {\n          // Only allow this for Sprites or Movie clips, to prevent\n          // Container scaling bug\n          if (sprite instanceof this.Sprite || sprite instanceof this.AnimatedSprite) {\n            sprite.width = sprite._currentWidth\n            sprite.height = sprite._currentHeight\n          }\n        }\n        if (this.properties.scale) {\n          sprite.scale.x = sprite._currentScaleX\n          sprite.scale.y = sprite._currentScaleY\n        }\n        if (this.properties.alpha) {\n          sprite.alpha = sprite._currentAlpha\n        }\n        if (this.properties.tile) {\n          if (sprite.tilePosition !== undefined) {\n            sprite.tilePosition.x = sprite._currentTilePositionX\n            sprite.tilePosition.y = sprite._currentTilePositionY\n          }\n          if (sprite.tileScale !== undefined) {\n            sprite.tileScale.x = sprite._currentTileScaleX\n            sprite.tileScale.y = sprite._currentTileScaleY\n          }\n        }\n\n        // Restore the sprite's children, if it has any\n        if (sprite.children.length !== 0) {\n          for (let i = 0; i < sprite.children.length; i++) {\n            // Find the sprite's child\n            const child = sprite.children[i]\n\n            // Restore the child sprite properties\n            restoreSpriteProperties(child)\n          }\n        }\n      }\n      for (let i = 0; i < this.stage.children.length; i++) {\n        const sprite = this.stage.children[i]\n        restoreSpriteProperties(sprite)\n      }\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./index.js"],"sourceRoot":""}